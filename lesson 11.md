* 비트 
  & : 양쪽 모두 참일때 참 
  | : 하나만 참이여도 참
```C#
int x = 61;  
//0000 0000 0000 0000 0000 0000 0011 1101(2)
//  0    0    0    0    0    0    3   D  (16)
int y = 55; 
//0000 0000 0000 0000 0000 0000 0011 0111(2)
//  0    0    0    0    0    0    3    7  (16)
//0은 거짓, 1은 참
// 0000 0000 0000 0000 0000 0000 0011 1101(2)
// 0000 0000 0000 0000 0000 0000 0011 0111(2)
//|0000 0000 0000 0000 0000 0000 0011 1111(2)  <-- bit or 연산 후 메모리에 저장  ==63(10)
                                
//&0000 0000 0000 0000 0000 0000 0011 0101(2)  <-- & bit and 연산 후 메모리에 저장  == 53(10)
//                                3     5 (16)
Console.WriteLine(x & y);  //서로 대응되는
Console.WriteLine("{0:X8}", x & y); 
 
Console.WriteLine(x | y);   //63
Console.WriteLine("{0:X8}", x | y);  //3F


// ^, 배타적 논리합, Exclusive Or
// 두 값이 달라야 1, 같으면 0
// 0000 0000 0000 0000 0000 0000 0011 1101(2)
// 0000 0000 0000 0000 0000 0000 0011 0111(2)
//^0000 0000 0000 0000 0000 0000 0000 1010(2)  <-- bit exclusive or연산 후 메모리에 저장
//                                      10(10)
//                                      A(16)
Console.WriteLine(x ^ y);  //10
Console.WriteLine("{0:X8}", x ^ y);   //A



// 반전 ~
// 0000 0000 0000 0000 0000 0000 0011 1101(2)  61(10)
//~1111 1111 1111 1111 1111 1111 1100 0010(2)  -62(10)
//  F     F    F    F    F    F    C    2 (16)
// 0000 0000 0000 0000 0000 0000 0011 1110(2)  62(10)3번째 윗줄에 있는 61에 +1한 값
Console.WriteLine(~x);  //-62
Console.WriteLine("{0:X8}", ~x);  //FFFFFFC2(16)

```
최상위 비트가 1이면 음수
기존 2진수에 반전된 값이(0->1, 1->0) 1의 보수
1의 보수법에 +1 한 값이 2의 보수가 됨




## 연산자 우선순위
(), {}, []
+, -, |, ~, ++, --
*, /, %
